import { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';
import { BadRequestError } from './internalErrorClasses.js';
export async function runBatchHttpQuery(server, batchRequest, body, contextValue, schemaDerivedData, internals) {
    if (body.length === 0) {
        throw new BadRequestError('No operations found in request.');
    }
    const combinedResponseHead = newHTTPGraphQLHead();
    const responseBodies = await Promise.all(body.map(async (bodyPiece) => {
        const singleRequest = {
            ...batchRequest,
            body: bodyPiece,
        };
        const response = await runHttpQuery(server, singleRequest, contextValue, schemaDerivedData, internals);
        if (response.body.kind === 'chunked') {
            throw Error('Incremental delivery is not implemented for batch requests');
        }
        for (const [key, value] of response.headers) {
            combinedResponseHead.headers.set(key, value);
        }
        if (response.status) {
            combinedResponseHead.status = response.status;
        }
        return response.body.string;
    }));
    return {
        ...combinedResponseHead,
        body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },
    };
}
export async function runPotentiallyBatchedHttpQuery(server, httpGraphQLRequest, contextValue, schemaDerivedData, internals) {
    if (!(httpGraphQLRequest.method === 'POST' &&
        Array.isArray(httpGraphQLRequest.body))) {
        return await runHttpQuery(server, httpGraphQLRequest, contextValue, schemaDerivedData, internals);
    }
    if (internals.allowBatchedHttpRequests) {
        return await runBatchHttpQuery(server, httpGraphQLRequest, httpGraphQLRequest.body, contextValue, schemaDerivedData, internals);
    }
    throw new BadRequestError('Operation batching disabled.');
}
//# sourceMappingURL=httpBatching.js.map